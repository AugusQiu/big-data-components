## 为什么使用消息队列（MQ)？
* 解耦
* 异步
* 削峰
### 解耦
场景：A系统要发送数据到B、C系统，传统方式通过代码调用B、C提供的接口，如果以后新增了个D系统，删除了个C系统，就需要不断去修改，扩展性差；高耦合，如果A系统生产了一条非常重要的数据，其他与它耦合的系统都需要，A系统就得时刻考虑 B、C、D 挂了怎么办？需不需要重发？需不需要暂存这条消息  
有了MQ，A系统生产了一条数据，只需要关注 发送到MQ，如果新系统需要数据，直接从MQ里面取出来消费即可。这样一来，**A系统就无需再考虑要给谁发送数据，不用再维护这个代码，也无需再考虑别的系统是否调用成功、是否超时失败等**  
> 结合 pub/sub 发布订阅模型，通过一个MQ实现系统间的解耦 

### 异步
场景：A系统接收一个请求，不仅要在自己本地写库，还要在 B、C、D三个系统写库，自己本地写要100ms，BCD分别需要 200ms、300ms、300ms，这样请求总延时 高达 900ms，用户体验非常慢（ps:一般，请求在200ms以内完成，用户几乎是无感知的)  
如果使用 MQ，A系统连续发送 3条消息到MQ队列中，假如总耗时 150ms，那么A系统从接受一个请求到返回 响应给用户，总时长是 100 + 150 = 250ms

### 削峰  
场景：每天 00:00~12:00，A系统风平浪静，每秒并发请求数量50个；到 12:00~14:00，每秒并发请求数量暴增到 3K+，系统是基于MySQL的，大量请求涌入 MySQL，每秒钟执行 3k+ 条SQL，一般情况，MySQL扛到每秒2k个请求差不多了，太多就很可能造成系统崩溃；14:00之后，就又是低峰期  
如果使用，每秒3k个请求写入MQ，系统从MQ中慢慢拉取请求，每秒就拉取2k，不超过自己每秒能处理的最大请求数量，这样高峰期，系统就很难挂掉。唯一的问题是，MQ每秒3k请求进来，2k出去，会造成1k请求的**积压**，短暂的高峰期积压。一般高峰期过后，就又是每秒50个请求进MQ, 系统暂时还是按照每秒2k个请求在处理，积压也会被快速解决  

### 缺点
* 系统可用性降低：系统引入外部依赖越多，越容易挂掉；本来就是A系统单纯地调用 BCD接口，现在中间加了个MQ,如果MQ挂了，整套系统都是崩溃的  
* 系统复杂度提高：如何保证 消息没有被重复消费？怎么处理消息丢失的情况？保证消息传递的顺序性？
* 一致性问题：A系统处理完就直接返回成功，用户也就任务这个请求成功，但是出现问题，BCD三个系统那里，B、D两个系统写库成功，C却是失败了，数据不一致  

## Kafka和RabbitMQ消息队列
* 单机吞吐量：RBMQ只有万级，kafka高达10万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景  
* topic数量对吞吐量的影响：kafka的topic是从几十到几百个的时候，吞吐量会大幅度下降，在同等机器下，kafka尽量保证topic数量不要过多，如果要支撑大规模的topic，需要增加更多的机器资源  
* 可用性：RBMQ 基于主从架构实现；kafka是分布式，一个数据多个副本，少数机器宕机，不会丢失数据